package router

import (
	"fmt"
	"net/http"
	"regexp"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"

	"market.ir/internal/handler"
)

func RegisterRouter() *gin.Engine {
	r := gin.Default()

	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"*"},
		AllowHeaders:     []string{"Origin"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}))

	r.GET("/ping", handler.Ping)
	r.GET("/q/:searching_keyword", handler.QueryHandler)

	r.POST("/feedback", handler.FeedBackHandler)

	r.GET("/dev", func(c *gin.Context) {
		text := `انبوه مهندسی برای زبان‌های ایستا (مثل جاوا اسکریپت) و زبان‌های پویا (مثل LuaJIT از
		<a href="https://en.wikipedia.org/wiki/Lua_(programming_language)" target="_blank" rel="nofollow ">Lua</a> یا V8 جاوا اسکریپت و PyPy پایتون) وارد کامپایلرهای <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="nofollow ">JIT</a> 
		شدند و آن‌ها را به رقیب عملکردی سیستم‌های زبان‌های برنامه‌نویسی سیستمی (C++، C) تبدیل کردند. سیستم‌های توزیع‌شده
		و بزرگی مثل <a href="https://en.wikipedia.org/wiki/Apache_Spark" target="_blank" rel="nofollow ">
		اسپارک </a>در اسکالا نوشته شدند. زبان‌های برنامه‌نویسی جدید مثل
		<a href="https://en.wikipedia.org/wiki/Julia_(programming_language)" target="_blank" rel="nofollow ">جولیا</a> و <a href="https://en.wikipedia.org/wiki/Swift_(programming_language)" target="_blank" rel="nofollow ">سویفت</a> هم محدودیت‌هایی را برای زبان‌های زباله‌روب (Garbage Collector) به وجود آوردند.</p> <p>هیئتی به نام برنامه‌نویسی سیستم در سال ۲۰۱۴ و بعد از آن، شامل بزرگ‌ترین مغزهای زبان‌های برنامه‌نویسی کنونی از جمله <a href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup" target="_blank" rel="nofollow ">بیجارن استروستراپ</a> (خالق ++C)، <a href="https://en.wikipedia.org/wiki/Rob_Pike" target="_blank" rel="nofollow ">روب پایک</a> (خالق <a href="https://en.wikipedia.org/wiki/Go_(programming_language)" target="_blank" rel="nofollow ">Go</a>)، <a href="https://en.wikipedia.org/wiki/Andrei_Alexandrescu" target="_blank" rel="nofollow ">آندری آلکساندرسکو</a> (توسعه‌دهنده‌ی <a href="https://en.wikipedia.org/wiki/D_(programming_language)" target="_blank" rel="nofollow ">D</a>) و نیکو <strong>ماتساکیس</strong> (توسعه‌دهنده‌ی <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)" target="_blank" rel="nofollow ">Rust</a>). زبان برنامه‌نویسی سیستم در سال ۲۰۱۴ را این گونه توصیف می‌کنند:</p> <ul> <li><strong>نیکو ماستاکیس:</strong> برنامه‌نویسی سیستم مانند نوشتن برنامه‌های سمت کلاینت است، یعنی دقیقا نقطه‌ی مقابل GO قرار می‌گیرد. در این برنامه‌ها تأخیر بالایی وجود دارد و همین‌طور پیش‌نیازهایی مثل امنیت بالا و پیش‌نیازهای دیگر وجود دارند که در سمت سرور ارائه نمی‌شوند.</li> <li><strong>بیجارت استروستراپ</strong>: برنامه‌نویسی سیستم از کار با سخت‌افزار سرچشمه گرفته است که بعد از آن پیچیدگی برنامه‌ها افزایش یافت. در برنامه‌نویسی سیستم
		 با این پیچیدگی‌ها سروکار دارید، پس اگر با مشکلاتی مثل محدودیت منابع روبه‌رو شدید، بدانید در قلمروی برنامه‌نویسی سیستم قرار گرفته‌اید. محدودیت‌ها تعیین می‌کنند زبان، برنامه‌نویسی سیستم است یا خیر. آیا حافظه‌ رو به اتمام است؟ آیا زمان شما رو به پایان است؟</li> <li><strong>راب پایک:</strong> وقتی برای اولین بار GO را معرفی کردیم آن را یک زبان برنامه‌نویسی سیستم خواندیم و البته متأسفانه افرادی به اشتباه تصور کردند این زبان برای نوشتن <a href="/programming/" target="_blank">سیستم عامل</a> طراحی شده است. به عقیده‌ی ما این زبان مخصوص نوشتن سرور است یا می‌توان گفت یک زبان زیرساخت ابری است. بر اساس یک تعریف دیگر به برنامه‌نویسی که در کلود اجرا شود برنامه‌نویسی سیستم گفته می‌شود.</li> <li><strong>آندری آلکساندرسکو</strong>: من چند تست برای تعریف برنامه‌نویسی سیستم اجرا کردم. زبان‌های برنامه‌نویسی سیستم باید امکان نوشتن تخصیص‌گر حافظه را بدهند. در این زبان باید قادر به ساخت یک شماره در اشاره‌گر باشید زیرا عملکرد سخت‌افزار به این صورت است.</li> </ul> <p style="clear:both"> <img loading="lazy" class="img-responsive" style="display:block;margin-right:auto;margin-left:auto" src="https://cdn01.zoomit.ir/2018/9/13430890-499e-4aab-8baf-2f82fa8f4aef.jpg" alt="جاوا اسکریپت"/> </p> <p>رابطه‌ی برنامه‌نویسی سیستم با عملکرد بالا چیست؟ با محدودیت‌های منابع و کنترل سخت‌افزاری چطور؟ یا زیرساخت ابری؟ به‌طورکلی به نظر می‌رسد زبان‌هایی مثل C ،C++ ،Rust و D از نظر سطح انتزاع و خلاصه بودن از ماشین متمایز می‌شوند. این زبان‌ها جزئیات سخت‌افزار مثل تخصیص حافظه یا قالب و مدیریت دقیق منابع را نمایش می‌دهند.</p> <p>یک تعریف دیگر هم برای آن وجود دارد: در صورت روبه‌رو شدن با مشکل بازدهی یا بهینه‌سازی چه مقدار آزادی برای حل آن دارید؟ در زبان‌های برنامه‌نویسی سطح پائین با کنترل دقیق جزئیات ماشین می‌توانید هر مشکلی را حل کنید. می‌توانید دستورالعمل را بر کل آرایه‌ها اعمال کنید و ساختار داده‌ای به‌دست‌آمده را در <a href="https://fa.wikipedia.org/wiki/%D8%AD%D8%A7%D9%81%D8%B8%D9%87_%D9%86%D9%87%D8%A7%D9%86" target="_blank" rel="nofollow ">کش (Cache)</a> ذخیره کنید. همان‌طور که انواع ایستا مثل جمع‌ اعداد صحیح با اطمینان بیشتری اجرا می‌شوند زبان‌های برنامه‌نویسی سطح پائین هم اجرای مطمئن‌تر دارند به‌طوری‌که کدها همان‌طور که تعریف می‌شوند اجرا می‌شوند.</p> <p>در مقابل، بهینه‌سازی زبان‌های تفسیر شده بسیار پیچیده است. به‌راحتی نمی‌توان از اجرای قابل‌انتظار کد توسط Runtime اطمینان حاصل کرد. همین مسئله در کامپایلرهای موازی‌ خودکار هم وجود دارد (<strong>Vectorizaiton</strong> یا برنامه‌نویسی آرایه‌ای یک مدل برنامه‌نویسی نیست. بلکه مانند نوشتن یک واسطه در پایتون است، برای مثال انتظار دارید یک تابع در صورت فراخوانی خروجی int (صحیح) تولید کند).</p> <h2>امروز: بنابراین برنامه‌نویسی سیستم چیست؟</h2> <p>اغلب به برنامه‌نویسی سطح پائین، برنامه‌نویسی سیستم می‌گویند (با اشاره به جزئیات ماشین)؛ اما معنی سیستم چیست؟ با بازگشت به تعریف ۱۹۷۲ می‌توان گفت:</p> <p>۱.مسئله‌ی قابل حل، ماهیت گسترده‌ای دارد و شامل تعداد زیادی مسائل فرعی و متنوع است.</p> <p>۲. از 
		 برنامه‌ی سیستمی برای پشتیبانی از برنامه‌های کاربردی و نرم‌افزاری دیگر استفاده می‌شود اما درعین‌حال می‌تواند بسته‌ی کاملی از برنامه‌ها هم باشد.</p> <p>۳. برنامه‌ی سیستمی برای تولید پیوسته طراحی شده است نه به عنوان راه‌حلی یک جا برای حل مشکلی در برنامه‌ها.</p> <p>۴. برنامه‌ی سیستمی از نظر تعداد و انواع ویژگی‌های تحت پشتیبانی به صورت پیوسته در حال تکامل است.</p> <p>۵. یک برنامه‌ی سیستمی به یک ساختار یا برنامه‌ی مشخص داخل و میان ماژول‌ها (برای مثال برقراری ارتباط) نیاز دارد و معمولا توسط بیش از یک شخص یا گروهی از اشخاص طراحی و پیاده‌سازی می‌شود.</p> <p>به نظر می‌رسد این گزینه‌ها بیشتر به مشکلات مهندسی نرم‌افزار اشاره دارند (پیمانه‌ای بودن، قابلیت استفاده‌ی مجدد، تکامل کد) تا مشکلات عملکردی سطح پائین. این یعنی هر زبان برنامه‌نویسی که حل این مشکلات را در اولویت قرار دهد یک زبان برنامه‌نویسی سیستمی است! البته این گزینه‌ها برای تعریف یک زبان برنامه‌نویسی سیستمی کافی نیستند؛ بنابراین می‌توان گفت زبان‌های برنامه‌نویسی پویا یا داینامیک از زبان‌های سیستمی دور هستند.</p> <p style="clear:both"> <img loading="lazy" class="img-responsive" style="display:block;margin-right:auto;margin-left:auto" src="https://cdn01.zoomit.ir/2018/9/1f6d6387-c605-4774-abbe-acc7dee5afc7.jpg" alt="سی پلاس پلاس"/> </p> <p>اما مفهوم دقیق این تعریف چیست: زبان‌های تابعی مثل <a href="https://en.wikipedia.org/wiki/OCaml" target="_blank" rel="nofollow ">Ocaml</a> و <a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)" target="_blank" rel="nofollow ">Haskell</a> بیشتر از زبان‌های سطح پائین مثل C یا ++C به سیستم وابسته هستند. هنگام آموزش برنامه‌نویسی باید اصول برنامه‌نویسی
		  تابعی مثل ارزش ثبات،
		 تأثیر سیستم‌های نوع غنی در بهبود طراحی واسطه و استفاده از توابع مرتبه بالاتر را درنظر گرفت. مدارس باید برنامه‌نویسی سیستم و سطح پائین را آموزش دهند.</p> <p>بنابراین آیا تفاوتی بین برنامه‌نویسی سیستم و مهندسی نرم‌افزار وجود دارد؟ پاسخ منفی است اما مشکل اینجاست که مهندسی نرم‌افزار و برنامه‌نویسی سطح پائین اغلب اوقات به صورت مجزا تدریس می‌شوند. با این حال اغلب کلاس‌های مهندسی نرم‌افزار معمولا بر شعار <strong>نوشتن</strong> <strong>واسطه‌ها و تست‌های مناسب</strong> جاوا متمرکز هستند، به همین دلیل لازم است روش طراحی سیستم با توجه به محدودیت‌های زیاد منابع آموزش داده شود.</p> <div class="pullquote rarticle">بهتر است به جای عبارت برنامه‌نویسی سیستم از برنامه‌نویسی سطح پائین استفاده شود</div> <p>شاید به این دلیل برنامه‌نویسی سطح پائین را سیستم می‌نامند که جذاب‌ترین سیستم‌های نرم‌افزاری از نوع سطح پائین هستند (برای مثال، پایگاه داده‌ها، شبکه‌ها، سیستم‌های عامل و...). از آنجا که سیستم‌های سطح پائین محدودیت‌های زیادی دارند، برای طراحی آن‌ها نیاز به تفکر خلاق است.</p> <p>در قدم بعدی، برنامه‌نویس زبان سطح پائین باید به این سؤال پاسخ دهد که کدام ایده‌های طراحی سیستم را می‌توان برای کار با سخت‌افزار مدرن تطبیق داد. انجمن Rust در این رابطه عملکرد نوآورانه‌ای داشته است، این انجمن چگونگی پیاده‌سازی اصول برنامه‌نویسی تابعی یا طراحی نرم‌افزاری بر مسائل سطح پائین را بررسی می‌کند (برای مثال مسائلی مثل قراردادها، کنترل خطا یا امنیت حافظه).</p> <p>به طور خلاصه بهتر است به‌جای عبارت برنامه‌نویسی سیستم از برنامه‌نویسی سطح پائین استفاده کرد. اهمیت طراحی سیستم‌های کامپیوتری به عنوان یک رشته یا زمینه به خاطر نام آن نیست؛ بنابراین جداسازی این دو مفهوم، طراحی زبان برنامه‌نویسی را شفاف می‌کند و دیدگاه‌های مشترکی را نسبت به این دو حوزه به وجود می‌آورد: چگونه می‌توان سیستمی را حول محور ماشین یا برعکس طراحی کرد؟</p></div>
`
		removeHtmlTagsPattern, _ := regexp.Compile("(?mi)<[^>]*>")
		result := removeHtmlTagsPattern.ReplaceAllString(text, "")

		removeScriptTagsPattern, _ := regexp.Compile("(?mi)<script[\\s\\S]*?>[\\s\\S]*?<\\/script>")
		result = removeScriptTagsPattern.ReplaceAllString(result, "")

		removeNumberTagsPattern, _ := regexp.Compile("(?mi).\\s{1,}[۰۱۲۳۴۵۶۷۸۹]")
		result = removeNumberTagsPattern.ReplaceAllString(result, "")

		removeDoubleSpacePattern, _ := regexp.Compile("(?mi)\\s{2,}")
		result = removeDoubleSpacePattern.ReplaceAllString(result, " ")

		onlyValidString, _ := regexp.Compile("[a-zA-Zضصثقفغعهخحجچشسیبلاتنمکگظطزرذدپو].*?(\\.\\s|\\?\\s|\\!\\s|؟\\s|؛\\s)")
		sentence := onlyValidString.ReplaceAllString(result, "")
		list := onlyValidString.FindAllStringSubmatch(result, -1)
		for _, v := range list {
			if v[1] != "" {
				fmt.Printf("%s", v[1])
			}
		}

		c.JSON(http.StatusOK, map[string]interface{}{
			"text":         text,
			"post-process": result,
			"1st-sentence": sentence,
			"sentences":    list,
		})
	})

	return r
}
